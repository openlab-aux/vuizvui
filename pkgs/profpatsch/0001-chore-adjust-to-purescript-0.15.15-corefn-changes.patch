From d82d007edd2585f4392cfdd612a852bb3299830b Mon Sep 17 00:00:00 2001
From: Profpatsch <mail@profpatsch.de>
Date: Wed, 15 Oct 2025 18:50:41 +0200
Subject: [PATCH] chore: adjust to purescript 0.15.15 corefn changes
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Update CoreFn AST patterns to match changes in PureScript 0.15.15: Ann type remains 3-tuple, ObjectUpdate constructor uses 4 arguments (adds copyFields parameter), and add missing Control.Monad imports (when, zipWithM, forM_, unless) that are no longer re-exported.

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
---
diff --git a/src/PureNix/Convert.hs b/src/PureNix/Convert.hs
index 8034580..4ad36b5 100644
--- a/src/PureNix/Convert.hs
+++ b/src/PureNix/Convert.hs
@@ -5,6 +5,7 @@
 
 module PureNix.Convert (convert, ModuleInfo (..)) where
 
+import Control.Monad (when, zipWithM)
 import Data.Bitraversable
 import qualified Data.Map as M
 import Data.Set (Set)
@@ -54,7 +55,7 @@ localSpan :: SourceSpan -> Convert a -> Convert a
 localSpan spn = local (fmap $ const spn)
 
 localAnn :: Ann -> Convert a -> Convert a
-localAnn (spn, _, _, _) = localSpan spn
+localAnn (spn, _, _) = localSpan spn
 
 {-# ANN module' ("hlint: ignore Use list comprehension" :: String) #-}
 module' ::
@@ -106,7 +107,7 @@ expr :: Expr Ann -> Convert N.Expr
 expr (Abs ann arg body) = localAnn ann $ fmap (N.lam (N.mkVar arg)) (expr body)
 expr (Literal ann lit) = localAnn ann $ literal lit
 -- Newtype wrappers can always be removed.
-expr (App ann (Var (_, _, _, Just IsNewtype) _) x) = localAnn ann (expr x)
+expr (App ann (Var (_, _, Just IsNewtype) _) x) = localAnn ann (expr x)
 expr (App ann f x) = localAnn ann $ liftA2 N.app (expr f) (expr x)
 expr (Var ann (P.Qualified mqual name)) = localAnn ann $ do
   (_, thisModule, _) <- ask
@@ -116,7 +117,7 @@ expr (Var ann (P.Qualified mqual name)) = localAnn ann $ do
     _ -> N.var (N.mkVar name)
 expr (Accessor ann sel body) = localAnn ann $ flip N.sel (N.stringKey sel) <$> expr body
 expr (Let ann binds body) = localAnn ann $ liftA2 N.let' (bindings binds) (expr body)
-expr (ObjectUpdate ann a b) = localAnn ann $ liftA2 (N.bin N.Update) (expr a) (attrs b)
+expr (ObjectUpdate ann a _ b) = localAnn ann $ liftA2 (N.bin N.Update) (expr a) (attrs b)
 expr (Constructor _ _ (P.ProperName dataName) fields) = pure $ N.constructor dataName (N.mkVar <$> fields)
 expr (Case ann exprs cases) =
   localAnn ann $ do
@@ -171,7 +172,7 @@ zipBinders exprs binds = mconcat <$> zipWithM unbinder binds exprs
 unbinder :: Binder Ann -> N.Expr -> Convert ([N.Expr], [(N.Var, N.Expr)])
 unbinder (NullBinder _) _ = pure mempty
 unbinder (VarBinder _ name) scrut = pure $ (\name' -> ([], [(name', scrut)])) $ N.mkVar name
-unbinder (ConstructorBinder (_, _, _, Just IsNewtype) _ _ [field]) scrut = unbinder field scrut
+unbinder (ConstructorBinder (_, _, Just IsNewtype) _ _ [field]) scrut = unbinder field scrut
 unbinder (ConstructorBinder ann _ (P.Qualified _ (P.ProperName tag)) fields) scrut =
   localAnn ann $
     mappend ([N.bin N.Equals (N.sel scrut "__tag") (N.string tag)], []) . mconcat <$> zipWithM (\binder field -> unbinder binder (N.sel scrut field)) fields (N.numberedKeys "__field")
diff --git a/src/PureNix/Main.hs b/src/PureNix/Main.hs
index d393d8b..ec8fd17 100644
--- a/src/PureNix/Main.hs
+++ b/src/PureNix/Main.hs
@@ -2,6 +2,7 @@
 
 module PureNix.Main where
 
+import Control.Monad (forM_, unless)
 import qualified Data.Aeson as Aeson
 import Data.Aeson.Types (parseEither)
 import Data.Foldable (toList)
-- 
2.49.0

